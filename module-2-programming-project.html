<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 2 Programming Project</title>
<style>* { font-family: monospace; }</style>
<script>

// NOTE: You must implement the data structures using the prototype approach.
//       This is not what the book uses, so you have to convert it.
//       See also: https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/

// NOTE: Please review the following links regularly:
//       https://it.pointpark.edu/tutorials/arrays-vs-objects/
//       https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/
//       https://it.pointpark.edu/tutorials/implementation-vs-interface/



//---------//
// Project //
//---------//
console.log("Project");

// 1. Implement the stack data structure using the prototype.

// 2. It is possible to use a stack to check if the number of parentheses in a
//    string is balanced, meaning there are as many opening parentheses as
//    closing ones. In addition, we can also make sure that each opening
//    parenthesis precedes a closing parenthesis. Implement this algorithm.
//    HINT: When encountering '(' push to the stack and when encountering ')'
//    pop from the stack.

function isBalanced(str) {
  const stack = new Stack();

  for (let char of str) {
    if (char === '(') {
      stack.push(char);
    } else if (char === ')') {
      if (stack.isEmpty()) {
        return false; 
      }
      stack.pop();
    }
  }

  return stack.isEmpty();
}


// 3. Write a simple test program that shows your implementation in the
//    previous question works.
console.log(isBalanced("()"));
console.log(isBalanced("(())")); 
console.log(isBalanced("(()())")); 
console.log(isBalanced(")(")); 
console.log(isBalanced("()(")); 
// 4. Implement the queue data structure using the prototype.
function Queue() {
  this.items = [];
}
Queue.prototype.enqueue = function(item) {
  this.items.push(item);
};
Queue.prototype.dequeue = function() {
  if (!this.isEmpty()) {
    return this.items.shift();
  } else {
    return "Queue is empty";
  }
};
Queue.prototype.front = function() {
  if (!this.isEmpty()) {
    return this.items[0];
  } else {
    return "Queue is empty";
  }
};
Queue.prototype.isEmpty = function() {
  return this.items.length === 0;
};
Queue.prototype.size = function() {
  return this.items.length;
};
// 5. Create a queue that stores edibles, that can be either fruits or
//    vegetables. Use the constructor below to create the edible and store a
//    few of each kind in the queue (at least 3 of each).

function Edible(name, isFruit) {
  this.name = name;
  this.isFruit = isFruit; 
  this.toString = function() {
    return "Edible: " + this.name + " Fruit: " + this.isFruit;

    const apple = new Edible("fruit", "apple");
const banana = new Edible("fruit", "banana");
const carrot = new Edible("vegetable", "carrot");
const tomato = new Edible("vegetable", "tomato");

const edibleQueue = new Queue();

edibleQueue.enqueue(apple);
edibleQueue.enqueue(banana);
edibleQueue.enqueue(carrot);
edibleQueue.enqueue(tomato);

console.log("Front of the queue:", edibleQueue.front());
console.log("Queue size:", edibleQueue.size());
while (!edibleQueue.isEmpty()) {
  const edible = edibleQueue.dequeue();
  console.log("Dequeued:", edible.type, edible.name);
}
console.log("Is the queue empty?", edibleQueue.isEmpty());
  };
}



// 6. Create two more queues: one for fruits and one for vegetables. For this
//    question, only create them (and leave them empty).

const fruitQueue = new Queue();
const vegetableQueue = new Queue();

// 7. Dequeue all the elements from the edible queue and enqueue them in the
//    appropriate queue, either for fruits or vegetables.

while (!edibleQueue.isEmpty()) {
  const edible = edibleQueue.dequeue();
  if (edible.type === "fruit") {
    fruitQueue.enqueue(edible);
  } else if (edible.type === "vegetable") {
    vegetableQueue.enqueue(edible);
  }
}

// 8. Print the final contents to the console, showing that your code works.

console.log("Fruit Queue:");
while (!fruitQueue.isEmpty()) {
  const fruit = fruitQueue.dequeue();
  console.log(fruit.name);
}

console.log("Vegetable Queue:");
while (!vegetableQueue.isEmpty()) {
  const vegetable = vegetableQueue.dequeue();
  console.log(vegetable.name);
}


</script>
</head>
<body>
  See console!
</body>
</html>
